package kr.or.ddit.ddtown.controller.emp.artist;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import kr.or.ddit.ddtown.service.emp.artist.IArtistService;
import kr.or.ddit.vo.PaginationInfoVO;
import kr.or.ddit.vo.artist.ArtistVO;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Controller
@RequestMapping("/emp/artist")
public class ArtistManagementController {
	
	@Autowired
	private IArtistService artistService;
	
	@GetMapping("/artist-management")
	public String artistManagementPage(ArtistVO artistVO, Model model) {
		log.info("artistManagementPage() 실행");
		
		PaginationInfoVO<ArtistVO> pagingVO = new PaginationInfoVO<>();
		int currentPage = artistVO.getPage();
		String searchType = artistVO.getSearchType();
		String searchWord = artistVO.getSearchWord();
		
		if(StringUtils.isNotBlank(searchWord)) {
			pagingVO.setSearchType(searchType);
			pagingVO.setSearchWord(searchWord);
			
			// 검색 후 목록 갈때 검색내용 적용
			model.addAttribute("searchType", artistVO.getSearchType());
			model.addAttribute("searchWord", artistVO.getSearchWord());
		}
		
		try {
			// 현재 페이지 전달 후, start/endRow, start/endPage 설정
			pagingVO.setCurrentPage(currentPage);
			int totalRecord = artistService.selectArtistCount(pagingVO);
			pagingVO.setTotalRecord(totalRecord);
			List<ArtistVO> artistList = artistService.artistListWithPage(pagingVO);
			pagingVO.setDataList(artistList);
		} catch (Exception e) {
			e.printStackTrace();
			model.addAttribute("errorMessage", "아티스트 목록을 불러오는 중 오류가 발생했습니다!!");
		}
		
		model.addAttribute("pagingVO", pagingVO);
        return "emp/artist/artist-management";
	}
	
	@ResponseBody
	@PostMapping("/update")
	public ResponseEntity<Map<String, String>> updateArtist(@RequestBody ArtistVO artistToUpdate){
		log.info("updateArtist() 실행");
		log.info("아티스트 그룹 업데이트 요청 받음(ArtistVO 사용): {}", artistToUpdate);
		log.info("업데이트 대상 아티스트 번호: {}", artistToUpdate.getArtNo());
		
		Map<String, String> response = new HashMap<>();
		
		try {
			int cnt = artistService.updateArtist(artistToUpdate);

			if(cnt > 0) {
				response.put("status", "success");
				response.put("message", "아티스트 정보가 성공적으로 업데이트 되었습니다.");
				log.info("아티스트 정보 업데이트 성공 : 아티스트 번호 {}", artistToUpdate.getArtNo());
				return ResponseEntity.ok(response);
			}else {
			    response.put("status", "failed"); 
			    response.put("message", "아티스트 정보 업데이트에 실패했습니다. (변경된 내용이 없거나 대상 아티스트를 찾을 수 없습니다.)");
			    log.warn("아티스트 정보 업데이트 실패 (반환값 0): 아티스트 번호 {}", artistToUpdate.getArtNo());
			    return ResponseEntity.ok(response); 
			}
		} catch (Exception e) {
			e.printStackTrace();
			log.error("아티스트 정보 업데이트 중 서버 오류 발생: 아티스트 번호 {}", artistToUpdate.getArtNo(), e);
			response.put("status", "error");
			response.put("message", "서버 오류로 인해 아티스트 정보 업데이트에 실패했습니다: " + e.getMessage());
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
		}
	}
}






