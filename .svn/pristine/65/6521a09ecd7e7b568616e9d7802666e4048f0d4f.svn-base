package kr.or.ddit.ddtown.service.concert.schedule;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.or.ddit.ServiceResult;
import kr.or.ddit.ddtown.mapper.concert.schedule.IConcertScheduleMapper;
import kr.or.ddit.ddtown.service.file.IFileService;
import kr.or.ddit.vo.PaginationInfoVO;
import kr.or.ddit.vo.concert.ConcertVO;
import kr.or.ddit.vo.file.AttachmentFileDetailVO;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class ConcertServiceImpl implements IConcertService { 

    @Autowired
    private IConcertScheduleMapper concertMapper; 
    
    @Autowired
    private IFileService fileService;
    
    private static final String FILETYPECODE = "FITC010";

    @Override
    public List<ConcertVO> selectConcertList(PaginationInfoVO<ConcertVO> pagingVO) throws Exception {
        log.info("selectConcertList() 실행...!");
        List<ConcertVO> list = concertMapper.selectConcertList(pagingVO);
        if (list != null) {
            for (ConcertVO item : list) { 
                item.setRepresentativeImageUrl(null); // 반복문 시작 시 null 초기화
                if (item.getFileGroupNo() != null && item.getFileGroupNo() > 0) {
                    try {
                        log.debug("콘서트 ID {}의 파일 그룹 {}에 대한 대표 이미지 조회 시도.", item.getConcertNo(), item.getFileGroupNo());
                        AttachmentFileDetailVO repFile = fileService.getRepresentativeFileByGroupNo(item.getFileGroupNo());
                        if (repFile != null && repFile.getWebPath() != null && !repFile.getWebPath().isEmpty()) {
                            // *** VO에 대표 이미지 URL 설정 ***
                            item.setRepresentativeImageUrl(repFile.getWebPath());
                            log.info("목록 - 콘서트 ID {}: 설정된 대표 이미지 URL: [{}]", item.getConcertNo(), item.getRepresentativeImageUrl());
                        } else {
                            log.warn("목록 - 콘서트 ID {}: 대표 이미지 파일 정보를 찾지 못했거나 webPath가 비어있습니다. FileGroupNo: {}", item.getConcertNo(), item.getFileGroupNo());
                        }
                    } catch (Exception e) {
                        log.error("목록 - 콘서트 ID {}의 대표 이미지 조회 중 오류 발생: {}", item.getConcertNo(), e.getMessage());
                        // 개별 항목 오류 시 전체 목록 조회를 막지 않도록 해놈
                    }
                } else {
                    // 파일 그룹 번호가 없는 경우
                    log.debug("목록 - 콘서트 ID {}: 파일 그룹 번호가 없거나 유효하지 않습니다.", item.getConcertNo());
                }
            }
        }
        return list;
    }

    @Override
    public int selectConcertCount(PaginationInfoVO<ConcertVO> pagingVO) throws Exception {
    	log.info("selectConcertCount() 실행...!");
        return concertMapper.selectConcertCount(pagingVO);
    }

    @Override
    public ConcertVO selectSchedule(int concertNo) throws Exception {
    	
    	log.info("selectSchedule() 실행...! 조회할 콘서트 번호: {}", concertNo);
    	ConcertVO concertVO = concertMapper.selectSchedule(concertNo); 
        if (concertVO != null && concertVO.getFileGroupNo() != null && concertVO.getFileGroupNo() > 0) {	// 일정정보가 비어있지 않을때
            // *** VO에 전체 첨부파일 목록 설정 ***
            List<AttachmentFileDetailVO> files = fileService.getFileDetailsByGroupNo(concertVO.getFileGroupNo());
            concertVO.setAttachmentFileList(files);
            log.debug("콘서트 ID {}: 파일 그룹 {}의 파일 {}개 로드", concertNo, concertVO.getFileGroupNo(), (files != null ? files.size() : 0));
        }
        return concertVO;
    }

    @Transactional
    @Override
    public ServiceResult insertSchedule(ConcertVO concertVO) throws Exception {
    	log.info("insertSchedule() 실행...!");
    	
    	// 1. 파일 업로드 처리 및 파일 그룹 번호 받기
        if (concertVO.getConcertFiles() != null && concertVO.getConcertFiles().length > 0 && !concertVO.getConcertFiles()[0].isEmpty()) {

            Integer fileGroupNo = fileService.uploadAndProcessFiles(concertVO.getConcertFiles(), FILETYPECODE);
            concertVO.setFileGroupNo(fileGroupNo); // 생성된 파일 그룹 번호를 ConcertVO에 설정
        } else {
            concertVO.setFileGroupNo(null);
        }

        // 2. 콘서트 일정 정보 DB에 삽입
        int row = concertMapper.insertSchedule(concertVO); // 이 때 fileGroupNo도 함께 저장됨
        log.info("DB 등록 후 concertNo (from VO after selectKey): {}", concertVO.getConcertNo());

        if (row > 0) {
            log.info("콘서트 일정 DB 등록 성공: {}", concertVO.getConcertNm());
            return ServiceResult.OK;
        }
        log.warn("콘서트 일정 DB 등록 실패: {}", concertVO.getConcertNm());
        return ServiceResult.FAILED;
    }

    @Transactional
    @Override
    public ServiceResult updateSchedule(ConcertVO concertVO) throws Exception {
    	log.info("updateSchedule() 실행...!");
    	
    	// 선택한 게시물의 기존 파일 그룹 번호 조회
        ConcertVO originalConcert = concertMapper.selectSchedule(concertVO.getConcertNo());
        Integer existingFileGroupNo = (originalConcert != null) ? originalConcert.getFileGroupNo() : null;
        log.info("기존 파일 그룹 번호: {}", existingFileGroupNo);

        boolean hasNewFiles = concertVO.getConcertFiles() != null &&
                              concertVO.getConcertFiles().length > 0 &&
                              !concertVO.getConcertFiles()[0].isEmpty();

        // 개별 파일 삭제 처리
        // FileServiceImpl의 deleteSpecificFiles 호출
        // existingFileGroupNo가 null 될 수 있음 (그룹 내 모든 파일 삭제 시)
        if (concertVO.getDeleteFileNos() != null && !concertVO.getDeleteFileNos().isEmpty()) {
            log.info("삭제 요청된 파일 번호: {}", concertVO.getDeleteFileNos());
            fileService.deleteSpecificFiles(concertVO.getDeleteFileNos(), existingFileGroupNo);
            // 개별 파일 삭제 후, 파일 그룹에 남은 파일이 있는지 확인하여 existingFileGroupNo를 업데이트
            if (existingFileGroupNo != null) {
                List<AttachmentFileDetailVO> remainingFiles = fileService.getFileDetailsByGroupNo(existingFileGroupNo);
                if (remainingFiles == null || remainingFiles.isEmpty()) {
                    log.info("모든 개별 파일 삭제 후 파일 그룹 {}도 삭제 : ", existingFileGroupNo);
                    existingFileGroupNo = null; // 그룹이 비었거나 삭제되었으므로 null 처리
                }
            }
        }
        // concertVO의 fileGroupNo를 현재 상태(existingFileGroupNo)로 일단 동기화
        concertVO.setFileGroupNo(existingFileGroupNo);


        // 새로 첨부된 파일 처리
        if (hasNewFiles) {
            // 새 파일 넣을 때 기존 파일 그룹 삭제
            if (existingFileGroupNo != null) {
                log.info("기존 파일 삭제", existingFileGroupNo);
                fileService.deleteFilesByGroupNo(existingFileGroupNo); // 기존 파일 및 그룹 정보 모두 삭제
            }

            // 새 파일들로 새로운 파일 그룹을 생성 
            log.info("새 파일들을 업로드,  새 파일 그룹을 생성");
            Integer newFileGroupNo = fileService.uploadAndProcessFiles(concertVO.getConcertFiles(), FILETYPECODE);
            concertVO.setFileGroupNo(newFileGroupNo); // 생성된 새 파일 그룹 번호로 ConcertVO 업데이트
            log.info("새 파일 업로드 완료. 새 파일 그룹 번호: {}", newFileGroupNo);

        } else {
            // 새 파일이 첨부되지 않은 경우
            log.info("새로 첨부된 파일이 없습니다. 기존 파일 상태를 유지하거나, 개별 삭제가 반영됩니다.");
        }

        // 콘서트 일정 정보 DB 업뎃
        int row = concertMapper.updateSchedule(concertVO);
        if (row > 0) {
            log.info("콘서트 일정 DB 업데이트 성공 (번호: {})", concertVO.getConcertNo());
            return ServiceResult.OK;
        }
        log.warn("콘서트 일정 DB 업데이트 실패 (번호: {}): {}", concertVO.getConcertNo());
        return ServiceResult.FAILED;
    }

    @Transactional
    @Override
    public ServiceResult deleteSchedule(int concertNo) throws Exception {
    	log.info("deleteSchedule() 실행...!");
        
    	ConcertVO concertToDelete = concertMapper.selectSchedule(concertNo); // 파일 그룹 번호 확인을 위해 조회

        if (concertToDelete != null && concertToDelete.getFileGroupNo() != null && concertToDelete.getFileGroupNo() > 0) {
            fileService.deleteFilesByGroupNo(concertToDelete.getFileGroupNo()); // 연관된 파일 모두 삭제
        }

        int row = concertMapper.deleteSchedule(concertNo);
        if (row > 0) {
            return ServiceResult.OK;
        }
        return ServiceResult.FAILED;
    }
}